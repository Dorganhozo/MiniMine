/*
* Documentação Oficial do MiniMine.
* Versão v0.0.1.
* Atualizada: 08/12/2025.
* Por: Shiniga-OP.
* Contribuidores da documentação: 
* Green: https://youtube.com/@greenlevelcreatordev?si=q1HhyS115FbbPhOI
* VDLN7: https://youtube.com/@violetbrasilofc?si=Ip8AkZdPnDDdFjGm
*/
basico:

vá até a pasta /MiniMine/mods/

adicione um arquivo .lua e escreva seu codigo nele. "script.lua" por exemplo.

abra o arquivo "arquivos.mini" e escreva o caminho de seu script nele.

inicie um mundo e veja seu script ser executado. Adicione mais scripts colocando seus caminhos separados por quebra de linha.

caso queira um loop de execução em tempo de jogo, crie um arquivo att.lua, que não precisa ser adicionado ao "arquivos.mini".

ele será um loop automatico do jogo, e tudo nele será executado diversas vezes até o app fechar.

API publica: <retorno/tipo> <identificador> <parâmetro/explicação>

jogador:

float jogador.posicao.x
float jogador.posicao.y
float jogador.posicao.z
float jogador.velo -- velocidade de movimento do jogador
float jogador.pulo -- forca do pulo
float jogador.GRAVIDADE
ModelInstance jogador.modelo
float jogador.VELO_MAX_QUEDA -- velocidade maxima que o jogador atinge em queda
String jogador.blocoSele -- o tipo do bloco em id que o jogador tem selecionado
int jogador.modo -- 0 = espectador, 1 = criativo, 2 = sobeevivencia
int jogador.ALCANCE -- alcance de destruicao e criacao de blocos
booelan jogador.noChao -- booleano
booelan jogador.naAgua -- booleano
void jogador:criarModelo3D() -- carrega o modelo padrão do jogador

jogador.inv:

int jogador.inv.quantSlots -- quantidade de slots para itens
float jogador.inv.tamSlot -- tamanho padrão dos slots
Slot[] jogador.inv.hotbarSlots
int jogador.inv.slotSelecionado -- indice do slot atual
booelan jogador.inv.aberto -- abre ou fecha inventario
void jogador.inv:rmItem(int slotId, int quantidade) -- remove o item de um slot pela quantidade
void jogador.inv:addItem(int blocoId, int quantidade) -- adiciona um item pelo tipo e quantidade
void jogador.inv:selecionarSlot(indice, jogador) -- seleciona um slot para o jogador

mundo:

String mundo.nome -- nome do mundo atual
int mundo.RAIO_CHUNKS -- chunks × raio = chunks ativas
int mundo.seed -- Retorna uma seed do Mundo
final int mundo.Y_CHUNK -- tamanho vertical das chuhks
final int mundo.TAM_CHUNK -- tamanho horizontal das chunks
booelan mundo.nuvens -- booleana, desativa e ativa as nuvens no céu
boolean mundo.ciclo -- ativa ou desativa o ciclo diário incluindo o tick
void mundo:defBlocoMundo(int x, y, z, String tipoDoBloco) -- define um bloco nas coordenadas globais
int mundo:obterBlocoMundo(int x, y, z) -- obtem o ID númerico do bloco nas coordenadas globais
Bloco mundo:addBloco(String nome, int texturaIdTopo) --  retorna o objeto e cria uma textura de um blocos com todas as faces da mesma textura, o nome precisa ser o mesmo da textura a ser usada no inventario
Bloco mundo:addBloco(String nome, int texturaIdTopo, int texturaIdLados) -- variacao
Bloco mundo:addBloco(String nome, int texturaIdTopo, int texturaIdLados, int texturaIdBaixo) -- variacao
Bloco mundo:addBloco(String nome, int texturaIdTopo, int texturaIdLados, boolean ehTransparente) -- variacao se é transparente, true, senao, false
Bloco mundo:addBloco(String nome, int texturaIdTopo, int texturaIdLados, boolean ehTransparente, int luz) -- variacao, nivel de luz de 0 a 15

mundo.texturas:

void mundo.texturas:add(textura) -- adiciona uma textura, faça mundo.texturas(util:carregarTextura(caminho)) para adicionar uma, e depois chame mundo:iniciar() no final do script

mundo.chunks:

int mundo.chunks:size() -- obtem a quantidade de objetos chunk a serem renderizados
Chunk mundo.chunks:get(Chave chave) -- retorna um objeto chunk e senão existir, retorna nil

mundo.chunksMod:

int mundo.chunksMod:size() -- obtem a quantidade de chunks modificadas pelo mundo
Chunk mundo.chunksMod:get(chave) -- mesma coisa so que com chunks alteradas sem Mesh se não visivel

mundo.s2D:

float mundo.s2D.ruido(float x, y) -- devolve um ruido 2D comum simplex
float mundo.s2D.ruidoFractal(float x, y, escala, octaves, persistencia) -- devolve um ruido fractal 2D simplex (max de 16 octaveis)
float mundo.s3D.ruido(float x, y, z) -- devolve um ruido 3D comum simplex
float mundo.s3D.ruidoFractal(float x, y, z, escala, octaves, persistencia) -- devolve um ruido fractal 3D simplex

ChunkUtil chunkutil:

void chunkutil:defBloco(int localX, localY, localZ, tipoId, Chunk chunk) -- define um bloco de coords locais
byte chunkutil:obterBloco(int localX, localY, localZ, Chunk chunk)
void chunkutil:defLuz(int localX, localY, localZ, nivel, Chunk chunk) -- define uma luz na chunk com um nivel luminosidade
int chunkutil:obterLuz(int localX, localY, localZ, Chunk chunk) -- retorna o nivel de luz na chunk
boolean chunkutil:ehSolido(int x, y, z, Chunk chunk) -- retorna verdadeiro se for solido e falso senão

Bloco bloco:

void bloco:addSom(String bloco, String... sons) -- quando o bloco for quebrado ou colocado, reproduzirá um desses sons aleatóriamente definidos com audio:addSom(...)
void bloco:tocarSom(String bloco) -- toca um dos sons do bloco definido aleatóriamente

Map<Integer, Bloco> bloco.numIds:

Bloco bloco.numIds:get(int id) -- retorna um objeto bloco baseado no seu ID dinamico de numero inteiro

Map<String, Bloco> bloco.texIds:

Bloco bloco.texIds:get(String nome) -- retorna um objeto Bloco baseado em seu ID imutavel de texto

UI ui:

int ui.fps -- taxa de quadros atuais
float ui.botoesTam -- tamanho padrao dos botoes

-- controles do jogador
boolean ui.direita
boolean ui.esquerda
boolean ui.tras
boolean ui.frente
booleanui.cima
boolean ui.baixo

Botao ui:addBotao(texturaId, x, y, escalaX, escalaY, nome, func_aoTocar) -- adiciona um botão e retorna seu objeto
Botao ui:addBotao(texturaId, x, y, escalaX, escalaY, nome, func_aoTocar, func_aoSoltar) -- variacao
Botao ui:addBotao(texturaId, x, y, escalaX, escalaY, nome, func_aoTocar, func_aoSoltar, func_aoAjustarATela(v, h)) -- variacao
void ui:rmBotao(nomeId) -- remove um botão da lista
void ui:subsBotao(nomeId, botaoObjeto) -- substitui um botão por outro objeto Botao
void ui:defTextoTam(escalaX, escalaY) -- define a escala do texto total
float[] ui:obterTextoTam() -- retorna um array de 2 elementos com X e Y da escala de texto
Texto ui:addTexto(texto, x, y) -- define e retorna um objeto Texto
Texto ui:addTexto(texto, x, y, func_aoAjustarATela(v, h)) -- variacao
void ui:subsTexto(nomeId, textoObj) -- substitui um texto pelo objeto
void ui:rmTexto(nomeId) -- remove um texto
void ui:abrirDialogo(titulo, textoPadrao, mensagemTemporaria, func_enter(texto)) -- cria um dialogo que executa uma função ao apertar enter
void ui:abrirDialogo(titulo, textoPadrao, mensagemTemporaria, func_enter(texto), func_cancelar) -- variação que executa uma função ao cancelar

Map<String, Botao> ui.botoes:

Botao ui.botoes:get(String nomeBotao) -- retorna o objeto Botao
void ui.botoes:get(String nomeBotao):defTextura(texturaId) -- define uma textura

Map<String, Texto> ui.textos:

Texto ui.textos:get(String nomeTexto) -- retorna o objeto Texto
String ui.textos:get(String nomeTexto).texto -- texto legivel


BiomasUtil biomas:

biomas:addBioma(function(String nome, float[] status, raridade)
-- definição de dados
nome[0] = "bioma comum"
status[0] = 0.1 -- temperatura
status[1] = 0.5 -- umidade
raridade[0] = 0.5
end, function(int localX, localZ, Chunk chunk)
-- geracao de coluna
local bloco = 1 -- grama
chunkutil:defBloco(localX, 0, localZ, bloco, chunk) -- define um bloco na chunk
end)
biomas:subsBioma(func_inicio, func_geracao, indice) -- substitui um bioma pelo indice
biomas:gerarArvore(localX, y, localZ, chunk) -- gera uma arvore dentro dos limites da chunk

Util util:

Texture util:carregarTextura(nomeId, caminho) -- carrega uma textura e guarda ela com um ID, além de retornar o objeto Texture
ModelInstance util:obterModeloGLTF(caminho) -- retorna um ModelInstance da LibGDX de um arquivo .gltf
BitmapFont util:carregarFonte(caminho, tamanhoInteiro) -- retorna a fonte bitmap, ui.fonte = util:carregarFonte(...) para alterar a fonte

int nuvens.RAIO_VISIVEL -- distancia que as nuvens cobrem ao redor do jogador
int nuvens.NUM_NUVENS -- quantidade de nuvens reutilizaveis no mundo

DiaNoiteUtil ciclo:

float ciclo.tempo -- tempo do dia noite, fica sempre entre 1.0 e 0.0
float ciclo.tempo_velo -- velocidade que influencia o ciclo diario e a velocidade das nuvens
boolean ciclo:ehDia() -- retorna se é dia booleano
boolean ciclo:ehNoite() -- retorna se é noite booleano
float ciclo.obterFatorTrancisao()

Map<String, Texture> texutil.texs:

int texutil.texs:size()
Texture texutil.texs:get(String nome)

audio:

Music audio:addSom(String nome, caminho) -- adiciona um som a lista e retorna um objeto Music, use som:play() como na LibGDX

HashMap<String, Music> audio.sons:

Music audio.sons:get(String nome) -- retorna um objeto Music

LuaAPI lua:

void lua:exec(String codigoTexto) -- executa um codigo Lua em tempo de execução
int lua.v -- tamanho vertical da tela
int lua.h -- tamanho horizontal da tela
String lua.pacote -- caminho absoluto da pasta mods

ArquivosUtil arquivos:

-- esses metodos dependem do nome do objeto Mundo passado
void arquivos:sv(mundo, jogador) -- salva o mundo(pode lagar)
void arquivos:cr(mundo, jogador) -- carrega o mundo(pode lagar também)
String arquivos:ler(lua.pacote .. "arquivo.txt") -- retorna o conteudo em string
void arquivos:escrever(lua.pacote .. "arquivo.txt", String texto) -- escreve uma string no caminho ou cria um arquivo com esse conteudo
boolean arquivos:existe(lua.pacote .. "arquivo.txt") -- retorna booleano
List<String> arquivos:listar(lua.pacote) -- retorna um objeto List<String> com os nomes de arquivos e pastas no caminho

## FUNÇÕES SOZINHAS ##

porFrame(function(delta)
   -- tudo aqui será executado a cada frame, só pode ter 1 chamada
end)

aoAjustar(function(v, h)
   -- tudo aqui será executado quando a tela atualizar, com os valores Verticais e Horizontais
end)

mapeamento de IDs:

blocos:

"grama"
"terra"
"pedra"
"agua"
"areia"
"tronco"
"folha"
"tabua_madeira"
"cacto"
"vidro"
"tocha"

texturas internas:

blocos:

"grama_topo"
"grama_lado"
"terra"
"pedra"
"agua"
"areia"
"tronco_topo"
"tronco_lado"
"folha"
"tabua_madeira"
"cacto_topo"
"cacto_lado"
"vidro"
"tocha"

animações:

"agua_a1"
"agua_a2"

interface:

"botao_f"
"botao_t"
"botao_d"
"botao_e"
"mira"
"clique"
"ataque"
"slot"
"botao_opcao"
"receita"

nomes de botões:

"direita"
"esquerda"
"cima"
"baixo"
"frente"
"tras"
"acao"
"ataque"
"inv"
"receita"

indices de biomas padrão:

0 = "floresta"
1 = "padrao"
2 = "deserto"
3 = "deserto_cactos"

IDs de aúdios:

"grama_1"
"terra_1"
"terra_2"
"terra_3"
"pedra_1"
"pedra_2"
"madeira_1"
"madeira_2"
"madeira_3"

sobre especificações:

todos os caminhos devem ser relativos a pasta "/MiniMine/mods/".

a unica classe que quebra essa regra é "arquivos".
